---
title: 设计哲学
description: 设计哲学
---

## Rust 的特性

2015 年 Rust 1.0 发布时，官方描述 Rust 的主要特点有以下几方面：

- 系统级语言
- 无 GC
- 基于 LLVM
- 内存安全
- 强类型 + 静态类型
- 混合编程范式
- 零成本抽象
- 线程安全

### 借鉴 Haskell 的特性

号称纯函数式的 Haskell 语言，它具有融合了范畴理论的类型系统，利用了范畴理论自身的代数性质和定律保证了程序自身的正确性。然而，Haskell 也有比较明显的缺点，那就是运行效率不高。反观 Rust 语言，它借鉴了 Haskell 的类型系统，保证了程序的正确性。值得一提的是，Rust 从 Haskell 的类型系统那里借鉴了以下特性：

- 没有空指针
- 默认不可变
- 表达式
- 高阶函数
- 代数数据类型
- 模式匹配
- 泛型
- trait 和关联类型
- 本地类型推导

### 借鉴 C++ 的特性

在类型系统的基础上，Rust 借鉴了现代 C++ 的内存管理机制，建立了所有权系统，两者保证了类型安全和内存安全；同时也解决了多线程并发编程中的数据竞争问题，默认线程安全，且不会牺牲性能。为了保证支持硬实时系统，Rust 从 C++ 那里借鉴了确定性析构、RAII 和智能指针，用于自动化地、确定性地管理内存，从而避免了 GC 的引入，因而就不会有 `世界暂停` 的问题了。这几项虽然借鉴自 C++，但是使用起来比 C++更加简洁。再看代码的可维护性，Rust 代码的可读性和抽象能力都是一流的，不仅拥有高的开发效率，还拥有可以和 C/C++ 媲美的性能。

## Rust 的内存安全

什么是内存安全呢？简单来说，就是不会出现内存访问错误。只有当程序访问未定义内存的时候才会产生内存错误。一般来说，发生以下几种情况就会产生内存错误：

- 引用空指针。
- 使用未初始化内存。
- 释放后使用，也就是使用悬垂指针。
- 缓冲区溢出，比如数组越界。
- 非法释放已经释放过的指针或未分配的指针，也就是重复释放。

为了保证内存安全，Rust 语言建立了严格的安全内存管理模型：
- 所有权系统。每个被分配的内存都有一个独占其所有权的指针。只有当该指针被销毁时，其对应的内存才能随之被释放。
- 借用和生命周期。每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。其中所有权系统还包括了从现代 C++那里借鉴的 RAII 机制，这是 Rust 无 GC 但是可以安全管理内存的基石。

## Rust 的类型安全

什么是类型安全呢？简单来说，类型安全是指类型系统可以保证程序的行为是意义明确、不出错的。一般来说，一门语言只要保证类型安全，就可以说它是一门安全的语言。像 C/C++ 语言的类型系统就不是类型安全的，因为它们并没有对无意义的行为进行约束。一个最简单的例子就是数组越界，在 C/C++ 语言中并不对其做任何检查，导致发生了语言规范规定之外的行为，也就是未定义行为 (Undefined Behavior)。而这些未定义行为恰恰是漏洞的温床。所以，像 C/C++ 这种语言就是类型不安全的语言。

Rust 语言如果想保证内存安全，首先要做的就是保证类型安全。在诸多编程语言中，`OCaml` 和 `Haskell` 是公认的类型安全的典范，它们的类型系统不仅仅有强大的类型论理论"背书"，而且在实践生产环境中也久经考验。所以，Rust 语言借鉴了它们的类型系统来保证类型安全，尤其是 Haskell，你能在 Rust 语言中看到更多 Haskell 类型系统的影子。

## Rust 的包管理工具

为了让开发者更方便地相互协作，Rust 提供了非常好用的包管理器 Cargo。值得一提的是，Rust 代码是以包 (crate) 为编译和分发单位的，Cargo 提供了很多命令，方便开发者创建、构建、分发、管理自己的包。Cargo 也提供插件机制，方便开发者编写自定义的插件，来满足更多的需求。比如官方提供的 `rustfmt` 和 `clippy` 工具，分别可以用于自动格式化代码和发现代码中的"坏味道"。再比如，`rustfix` 工具甚至可以帮助开发者根据编译器的建议自动修复出错的代码。Cargo 还天生拥抱开源社区和 Git，支持将写好的包一键发布到 [crates.io](https://crates.io/) 网站，供其他人使用。
